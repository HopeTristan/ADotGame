<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dot Drift - Global Multiplayer Game</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for a clean, full-screen game experience */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* Dark background */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            color: white;
            padding: 0;
            margin: 0;
            overflow: hidden; /* Prevent body scroll */
        }
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 95%;
            max-width: 1000px;
            margin: auto;
            border-radius: 1rem;
            box-shadow: 0 10px 20px rgba(0,0,0,0.5);
            background-color: #1f2937;
            padding: 1rem;
        }
        #game-canvas {
            background-color: #27303f; /* Slightly lighter inner game space */
            cursor: pointer;
            border-radius: 0.5rem;
            border: 2px solid #374151;
            width: 100%;
            height: calc(100vw * 0.5); /* Maintain aspect ratio (2:1) */
            max-height: 50vh;
            transition: border-color 0.2s;
        }
        #game-canvas:hover {
            border-color: #6366f1;
        }
        .chat-input-area {
            display: flex;
            width: 100%;
            margin-top: 1rem;
        }
        .chat-input {
            flex-grow: 1;
            padding: 0.75rem;
            border-radius: 0.5rem 0 0 0.5rem;
            border: 1px solid #4b5563;
            background-color: #374151;
            color: white;
        }
        .chat-send-btn {
            padding: 0.75rem 1.5rem;
            background-color: #4f46e5;
            color: white;
            font-weight: 600;
            border-radius: 0 0.5rem 0.5rem 0;
            transition: background-color 0.2s;
        }
        .chat-send-btn:hover {
            background-color: #4338ca;
        }
        .log-box {
            height: 100px;
            overflow-y: auto;
            border: 1px solid #4b5563;
            background-color: #374151;
            padding: 0.5rem;
            border-radius: 0.5rem;
            margin-top: 1rem;
            font-size: 0.875rem;
        }
        .user-input {
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            border: 1px solid #4b5563;
            background-color: #374151;
            color: white;
            max-width: 150px;
        }
    </style>
    <!-- Firebase Imports -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, onSnapshot, setDoc, collection, query, serverTimestamp, getDoc, where, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // Expose Firebase functions globally for use in the script below
        window.firebase = {
            initializeApp, getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged,
            getFirestore, doc, onSnapshot, setDoc, collection, query, serverTimestamp, setLogLevel, getDoc, where, deleteDoc
        };
    </script>
</head>
<body onload="initApp()">

    <div class="game-container">
        
        <!-- Player Info and Color Picker -->
        <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center w-full mb-4 px-2 space-y-2 sm:space-y-0">
            <div class="flex items-center space-x-2">
                <span class="text-sm text-gray-400">ID: <span id="player-id">Loading...</span></span>
                <span id="stick-status" class="text-sm font-semibold ml-4 text-orange-400"></span>
            </div>
            
            <!-- Username Input -->
            <div class="flex items-center space-x-2">
                <label for="username-input" class="text-sm font-medium">Username:</label>
                <input type="text" id="username-input" placeholder="Set your name" class="user-input" maxlength="12">
            </div>

            <!-- Color Picker -->
            <div class="flex items-center space-x-2">
                <label for="color-picker" class="text-sm font-medium">My Color:</label>
                <input type="color" id="color-picker" value="#4f46e5" class="w-8 h-8 rounded-full border-none p-0 cursor-pointer">
            </div>
        </div>
        
        <!-- Game Canvas -->
        <canvas id="game-canvas"></canvas>

        <!-- Status Log -->
        <div id="log" class="log-box w-full text-gray-400">
            [System] **Movement:** W/A/S/D or Arrows. **Feature:** Find the spinning stick near a tree!
        </div>
        
        <!-- Chat Input -->
        <div class="chat-input-area">
            <input type="text" id="chat-input" placeholder="Say something to the world (Press / to focus)..." class="chat-input" maxlength="100">
            <button id="send-btn" class="chat-send-btn">Send</button>
        </div>
    </div>
    
    <!-- Elder Dot Chat Modal (Hidden by default) -->
    <div id="elder-chat-modal" class="fixed inset-0 bg-black bg-opacity-75 hidden flex items-center justify-center p-4 z-50">
        <div class="bg-white p-6 rounded-xl w-full max-w-md shadow-2xl">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">The Elder Dot Speaks</h2>
            <div id="elder-response" class="bg-gray-100 p-3 rounded-lg mb-4 text-gray-700 max-h-40 overflow-y-auto">
                Ask me anything about the Dot Drift world. I can search the web for answers!
            </div>
            
            <input type="text" id="elder-query" placeholder="Ask the Elder Dot a question..." 
                   class="w-full p-2 border border-gray-300 rounded-lg mb-4 text-gray-800">
            
            <div class="flex justify-between space-x-2">
                <button id="close-elder-chat" class="bg-gray-500 text-white px-4 py-2 rounded-lg hover:bg-gray-600 transition duration-150">Close</button>
                <button id="send-elder-query" class="bg-purple-600 text-white px-4 py-2 rounded-lg hover:bg-purple-700 transition duration-150">Ask Dot</button>
            </div>
        </div>
    </div>


<script>
    // --- GLOBAL FIREBASE VARIABLES ---
    let db, auth;
    let userId = 'loading';
    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
    
    // --- GAME STATE AND CONSTANTS ---
    const MOVEMENT_SPEED = 0.5; // World units (0-100) per frame
    const PLAYER_RADIUS = 1.5;
    const PROXIMITY_RADIUS = 15; // Increased for easier house entry
    const BUMP_MAGNITUDE = 5; // How far a player is moved when bumped (World Units)

    // STICK CONSTANTS
    const STICK_TIMEOUT_MS = 5000; // 5 seconds of chaos
    const STICK_COOLDOWN_MS = 15000; // 15 seconds cooldown
    const STICK_RADIUS = 1.0;
    const STICK_PICKUP_DISTANCE = PLAYER_RADIUS + STICK_RADIUS + 1; // 4 world units
    
    let movementIntervalId = null; 
    let stickTimer = null; // Local timer for the 5-second hold

    let localPlayerState = { 
        x: 50, 
        y: 50, 
        color: '#4f46e5', 
        username: 'Loading...', 
        mapId: 'main', 
        vx: 0, 
        vy: 0,
        hasStick: false // New local state for stick ownership
    }; 

    const otherPlayers = {};

    // Global Stick State (mirrors Firestore)
    let globalStickState = {
        x: 0,
        y: 0,
        isHeld: false,
        holderId: null,
        cooldownUntil: 0 // Unix timestamp (local time)
    };

    let stickRotation = 0; // For visual spinning effect

    // --- MAP DEFINITIONS ---
    const MAPS = {
        main: {
            scenery: [
                // Trees (used for stick spawning)
                { type: 'tree', id: 'tree1', x: 20, y: 75, width: 3, height: 6, trunk: '#8B4513', canopy: '#10B981' }, 
                { type: 'tree', id: 'tree2', x: 80, y: 30, width: 3, height: 6, trunk: '#A0522D', canopy: '#059669' }, 
                { type: 'tree', id: 'tree3', x: 50, y: 20, width: 3, height: 6, trunk: '#502913', canopy: '#34D399' },
                // Houses (Entry Points)
                { type: 'house', id: 'house1_entry', x: 15, y: 25, size: 7, body: '#FCD34D', roof: '#EF4444' }, 
                { type: 'house', id: 'house2_entry', x: 85, y: 75, size: 7, body: '#93C5FD', roof: '#1E40AF' }  
            ],
            elderDot: { x: 50, y: 50, r: 5 }, 
            backgroundColor: '#27303f'
        },
        house1: {
            scenery: [
                // Floor/Wall
                { type: 'wall', x: 50, y: 50, width: 80, height: 80, color: '#6B7280' }, 
                // Simple Furniture
                { type: 'wall', x: 20, y: 20, width: 5, height: 10, color: '#9333ea' }, // Table
                { type: 'wall', x: 80, y: 80, width: 5, height: 5, color: '#f97316' }, // Chair
                // Exit point
                { type: 'exit', id: 'main_exit', targetMap: 'main', targetX: 20, targetY: 30, x: 50, y: 90, radius: 4, label: 'Exit' } 
            ],
            elderDot: null, 
            backgroundColor: '#4B5563' 
        }
    };
    
    // --- UTILITY FUNCTIONS ---
    function log(message, type = 'system') {
        const logElement = document.getElementById('log');
        let color = 'text-gray-400';
        if (type === 'chat') color = 'text-green-300';
        if (type === 'error') color = 'text-red-400';
        if (type === 'elder') color = 'text-purple-400 font-semibold';
        if (type === 'stick') color = 'text-orange-400 font-bold';
        
        const timestamp = new Date().toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
        
        logElement.innerHTML = `<p class="${color}">[${timestamp}] ${message}</p>` + logElement.innerHTML;
        
        while (logElement.children.length > 50) {
            logElement.removeChild(logElement.lastChild);
        }
    }

    function worldToCanvas(value, canvasSize) {
        return value * canvasSize / 100;
    }

    function canvasToWorld(value, canvasSize) {
        return value * 100 / canvasSize;
    }

    function distance(x1, y1, x2, y2) {
        return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
    }

    function findRandomTreeSpawn() {
        const trees = MAPS.main.scenery.filter(item => item.type === 'tree');
        if (trees.length === 0) return { x: 50, y: 50 }; // Fallback
        
        const tree = trees[Math.floor(Math.random() * trees.length)];
        
        // Offset the spawn point slightly from the tree center
        const offsetX = (Math.random() > 0.5 ? 1 : -1) * (tree.width * 2);
        const offsetY = (Math.random() > 0.5 ? 1 : -1) * (tree.height * 2);

        return { x: tree.x + offsetX, y: tree.y + offsetY };
    }

    // --- FIREBASE PATHS ---

    function getChatCollectionPath(appId) {
        return `artifacts/${appId}/public/data/chat`;
    }
    
    function getPlayerStatesCollectionPath(appId) {
        return `artifacts/${appId}/public/data/playerStates`;
    }

    function getStickStatePath(appId) {
        // Single document for the global stick state
        return firebase.doc(db, `artifacts/${appId}/public/data/stickState`, 'global_stick');
    }

    // --- FIREBASE INITIALIZATION & AUTHENTICATION ---

    async function initApp() {
        try {
            const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
            const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

            if (Object.keys(firebaseConfig).length === 0) {
                log('Error: Firebase configuration is missing.', 'error');
                return;
            }

            const app = firebase.initializeApp(firebaseConfig);
            db = firebase.getFirestore(app);
            auth = firebase.getAuth(app);
            firebase.setLogLevel('Debug');
            log(`[System] Initializing Firebase for App ID: ${appId}...`);

            await new Promise(resolve => {
                firebase.onAuthStateChanged(auth, async (user) => {
                    if (!user) {
                        if (initialAuthToken) {
                            await firebase.signInWithCustomToken(auth, initialAuthToken);
                        } else {
                            await firebase.signInAnonymously(auth);
                        }
                    }
                    userId = auth.currentUser?.uid || crypto.randomUUID();
                    document.getElementById('player-id').textContent = userId;
                    
                    // Set default username/mapId before listeners start
                    localPlayerState.username = `Dot_${userId.substring(0, 4)}`;
                    document.getElementById('username-input').value = localPlayerState.username;

                    resolve();
                });
            });

            setupEventListeners();
            initializeStickState(); // Initialize the stick state if it doesn't exist
            startStateListener(appId, userId);
            startChatListener(appId);
            startStickStateListener(appId);
            gameLoop(); // Start the game rendering loop

        } catch (error) {
            log(`[System] Fatal Initialization Error: ${error.message}`, 'error');
            console.error(error);
        }
    }

    // --- STICK LOGIC ---

    async function initializeStickState() {
        const stickRef = getStickStatePath(appId);
        const docSnapshot = await firebase.getDoc(stickRef);
        
        if (!docSnapshot.exists()) {
            const spawn = findRandomTreeSpawn();
            await firebase.setDoc(stickRef, {
                x: spawn.x,
                y: spawn.y,
                isHeld: false,
                holderId: null,
                cooldownUntil: Date.now() 
            }).catch(e => log(`[System] Error initializing stick: ${e.message}`, 'error'));
            log('[System] Initialized Spinning Stick.', 'stick');
        }
    }

    function startStickStateListener(appId) {
        const stickRef = getStickStatePath(appId);
        
        firebase.onSnapshot(stickRef, (doc) => {
            if (doc.exists()) {
                const data = doc.data();
                globalStickState = { ...data, cooldownUntil: data.cooldownUntil || 0 };
                
                // If this user is now holding the stick (and didn't initiate it)
                if (globalStickState.holderId === userId && !localPlayerState.hasStick) {
                    handleStickPickup(true); // Pickup initiated by external state change
                }
            }
        }, (error) => {
            log(`[System] Stick Listener Error: ${error.message}`, 'error');
        });
    }

    function handleStickPickup(remote = false) {
        if (localPlayerState.hasStick) return;

        localPlayerState.hasStick = true;
        log('[Stick] **CHAOS MODE ACTIVATED**! 5 seconds of BUMPING!', 'stick');

        document.getElementById('stick-status').textContent = '⚡️ Chaos Mode (5s)';

        // Update global state only if this is the initial local pickup
        if (!remote) {
            const stickRef = getStickStatePath(appId);
            firebase.setDoc(stickRef, {
                isHeld: true,
                holderId: userId,
            }, { merge: true }).catch(e => log(`[System] Error claiming stick: ${e.message}`, 'error'));
        }

        // Start local 5-second timer
        clearTimeout(stickTimer);
        stickTimer = setTimeout(handleStickDrop, STICK_TIMEOUT_MS);
    }

    async function handleStickDrop() {
        if (!localPlayerState.hasStick || !db) return;

        localPlayerState.hasStick = false;
        clearTimeout(stickTimer);
        stickTimer = null;

        document.getElementById('stick-status').textContent = 'Cooldown (15s)';
        log('[Stick] Stick broke! **15-second cooldown** begins.', 'stick');
        
        // Find new spawn location for the next stick
        const newSpawn = findRandomTreeSpawn();
        const cooldownEndsAt = Date.now() + STICK_COOLDOWN_MS;

        const stickRef = getStickStatePath(appId);
        try {
            await firebase.setDoc(stickRef, {
                isHeld: false,
                holderId: null,
                x: newSpawn.x,
                y: newSpawn.y,
                cooldownUntil: cooldownEndsAt
            }, { merge: true });

            // Update status display to show remaining cooldown
            let countdown = STICK_COOLDOWN_MS / 1000;
            const cooldownInterval = setInterval(() => {
                countdown--;
                if (countdown <= 0) {
                    clearInterval(cooldownInterval);
                    document.getElementById('stick-status').textContent = 'STICK READY!';
                } else {
                    document.getElementById('stick-status').textContent = `Cooldown (${countdown}s)`;
                }
            }, 1000);

        } catch (e) {
            log(`[System] Error dropping stick: ${e.message}`, 'error');
        }
    }

    // Send a push to another player's coordinates
    async function sendStickBump(targetId, dx, dy) {
        if (!db) return;
        const allPlayersRef = firebase.collection(db, getPlayerStatesCollectionPath(appId));
        const targetRef = firebase.doc(allPlayersRef, targetId);

        try {
            // Apply the bump movement directly to the target's coordinates
            // Use updateDoc to ensure we don't overwrite other fields, though setDoc merge is safer
            await firebase.setDoc(targetRef, { 
                x: target.x + dx, 
                y: target.y + dy, 
                lastActive: firebase.serverTimestamp()
            }, { merge: true });
            log(`[Stick] You BUMPED ${otherPlayers[targetId]?.username || targetId.substring(0, 4)}!`, 'stick');

        } catch(e) {
            log(`[System] Error bumping player: ${e.message}`, 'error');
            console.error(e);
        }
    }

    // --- FIRESTORE LISTENERS ---

    function startStateListener(appId, localUid) {
        const allPlayersRef = firebase.collection(db, getPlayerStatesCollectionPath(appId));
        
        firebase.onSnapshot(allPlayersRef, (snapshot) => {
            snapshot.forEach((doc) => {
                const data = doc.data();
                const uid = doc.id;

                if (uid === localUid) {
                    // Update local state and UI inputs based on Firestore data
                    localPlayerState = { 
                        ...localPlayerState, 
                        ...data,
                        username: data.username || localPlayerState.username,
                        color: data.color || localPlayerState.color,
                        mapId: data.mapId || 'main' 
                    };
                    document.getElementById('color-picker').value = localPlayerState.color;
                    document.getElementById('username-input').value = localPlayerState.username;

                    // Sync local stick state with global holder state
                    if (globalStickState.holderId !== localUid && localPlayerState.hasStick) {
                        // Another player took the stick or it was dropped remotely
                        localPlayerState.hasStick = false;
                        clearTimeout(stickTimer);
                        stickTimer = null;
                        document.getElementById('stick-status').textContent = '';
                        log('[Stick] Stick has been dropped or taken by another player.', 'system');
                    }

                } else {
                    // Store other players' states 
                    otherPlayers[uid] = data;
                }
            });
            drawGame();
        }, (error) => {
            log(`[System] State Listener Error: ${error.message}`, 'error');
        });

        // Set initial state 
        const myStateRef = firebase.doc(allPlayersRef, localUid);
        firebase.getDoc(myStateRef).then(docSnapshot => {
            if (!docSnapshot.exists() || !docSnapshot.data().username) {
                firebase.setDoc(myStateRef, { 
                    x: localPlayerState.x, 
                    y: localPlayerState.y, 
                    color: localPlayerState.color,
                    username: localPlayerState.username,
                    mapId: localPlayerState.mapId, 
                    lastActive: firebase.serverTimestamp() 
                }, { merge: true }).catch(e => {
                    log(`[System] Error setting initial state: ${e.message}`, 'error');
                });
            }
        });
    }

    function startChatListener(appId) {
        const chatRef = firebase.collection(db, getChatCollectionPath(appId));
        const q = firebase.query(chatRef); 

        firebase.onSnapshot(q, (snapshot) => {
            snapshot.docChanges().forEach((change) => {
                if (change.type === "added") {
                    const data = change.doc.data();
                    const senderId = data.userId;
                    
                    const senderState = otherPlayers[senderId] || (senderId === userId ? localPlayerState : null);
                    const senderName = senderState?.username || senderId.substring(0, 8);
                    const color = senderState?.color || '#9ca3af';

                    log(`<span style="color:${color};">[${senderName}]:</span> ${data.message}`, 'chat');
                }
            });
            // Clean up old chat messages (optional, for brevity)
            if (snapshot.docs.length > 50) {
                // Not strictly necessary for functionality, but good for cleanup
            }
        }, (error) => {
            log(`[System] Chat Listener Error: ${error.message}`, 'error');
        });
    }


    // --- SCENERY DRAWING HELPERS ---
    function drawTree(ctx, item, canvasWidth, canvasHeight) {
        const cx = worldToCanvas(item.x, canvasWidth);
        const cy = worldToCanvas(item.y, canvasHeight);
        const w = worldToCanvas(item.width, canvasWidth);
        const h = worldToCanvas(item.height, canvasHeight);
        const leafR = w * 1.5;

        // Trunk
        ctx.fillStyle = item.trunk;
        ctx.fillRect(cx - w / 2, cy - h / 2, w, h);

        // Canopy
        ctx.beginPath();
        ctx.arc(cx, cy - h / 2, leafR, 0, Math.PI * 2);
        ctx.fillStyle = item.canopy;
        ctx.fill();
        ctx.closePath();
    }

    function drawHouse(ctx, item, canvasWidth, canvasHeight) {
        const cx = worldToCanvas(item.x, canvasWidth);
        const cy = worldToCanvas(item.y, canvasHeight);
        const s = worldToCanvas(item.size, canvasWidth);
        const halfS = s / 2;

        // Body
        ctx.fillStyle = item.body;
        ctx.fillRect(cx - halfS, cy - halfS, s, s);

        // Roof
        ctx.beginPath();
        ctx.moveTo(cx - halfS, cy - halfS); 
        ctx.lineTo(cx + halfS, cy - halfS); 
        ctx.lineTo(cx, cy - halfS - s * 0.4); 
        ctx.closePath();
        ctx.fillStyle = item.roof;
        ctx.fill();
    }
    
    function drawWall(ctx, item, canvasWidth, canvasHeight) {
        const cx = worldToCanvas(item.x, canvasWidth);
        const cy = worldToCanvas(item.y, canvasHeight);
        const w = worldToCanvas(item.width, canvasWidth);
        const h = worldToCanvas(item.height, canvasHeight);

        ctx.fillStyle = item.color;
        ctx.fillRect(cx - w / 2, cy - h / 2, w, h);
    }
    
    function drawExit(ctx, item, canvasWidth, canvasHeight) {
        const cx = worldToCanvas(item.x, canvasWidth);
        const cy = worldToCanvas(item.y, canvasHeight);
        const r = worldToCanvas(item.radius, canvasWidth);

        // Draw the exit rectangle
        ctx.fillStyle = '#10B981'; 
        ctx.beginPath();
        ctx.rect(cx - r, cy - r, r * 2, r * 2);
        ctx.fill();

        // Draw label
        ctx.fillStyle = 'white';
        ctx.font = `${r * 0.7}px Inter`;
        ctx.textAlign = 'center';
        ctx.fillText(item.label, cx, cy + r * 0.2);
        ctx.fillText(`-> ${item.targetMap}`, cx, cy + r * 1.2);
    }

    function drawStick(ctx, item, canvasWidth, canvasHeight) {
        const cx = worldToCanvas(item.x, canvasWidth);
        const cy = worldToCanvas(item.y, canvasHeight);
        const r = worldToCanvas(STICK_RADIUS, canvasWidth);
        const length = r * 3;

        // Check if stick is available to draw (not held, not cooling down)
        if (globalStickState.isHeld || Date.now() < globalStickState.cooldownUntil) {
            return;
        }

        ctx.save();
        ctx.translate(cx, cy);
        
        // Spin the stick (4 degrees per frame)
        stickRotation += 4; 
        ctx.rotate(stickRotation * Math.PI / 180);

        // Draw the stick body
        ctx.fillStyle = '#A0522D'; // Brown
        ctx.fillRect(-r / 2, -length / 2, r, length);

        ctx.restore();
    }


    // --- GAME RENDERING ---

    function drawGame() {
        const canvas = document.getElementById('game-canvas');
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        
        const container = canvas.parentElement;
        canvas.width = container.clientWidth;
        canvas.height = container.clientWidth / 2;
        const canvasWidth = canvas.width;
        const canvasHeight = canvas.height;
        
        const currentMap = MAPS[localPlayerState.mapId] || MAPS.main;

        // Set background based on map
        canvas.style.backgroundColor = currentMap.backgroundColor;
        ctx.clearRect(0, 0, canvasWidth, canvasHeight);
        
        // 0. Draw Scenery
        currentMap.scenery.forEach(item => {
            if (item.type === 'tree') {
                drawTree(ctx, item, canvasWidth, canvasHeight);
            } else if (item.type === 'house') {
                drawHouse(ctx, item, canvasWidth, canvasHeight);
            } else if (item.type === 'wall') {
                drawWall(ctx, item, canvasWidth, canvasHeight);
            } else if (item.type === 'exit') {
                drawExit(ctx, item, canvasWidth, canvasHeight);
            }
        });

        // 0.1 Draw Stick (only on main map and if available)
        if (localPlayerState.mapId === 'main') {
            drawStick(ctx, globalStickState, canvasWidth, canvasHeight);
        }

        // 1. Draw Elder Dot 
        if (currentMap.elderDot) {
            const elder = currentMap.elderDot;
            const elderX = worldToCanvas(elder.x, canvasWidth);
            const elderY = worldToCanvas(elder.y, canvasHeight);
            const elderR = worldToCanvas(elder.r, canvasWidth);
            
            ctx.beginPath();
            ctx.arc(elderX, elderY, elderR, 0, Math.PI * 2);
            ctx.fillStyle = '#facc15'; 
            ctx.fill();
            ctx.closePath();
        }
        
        // 2. Draw Other Players (Only players on the same map)
        for (const uid in otherPlayers) {
            const player = otherPlayers[uid];
            if (player.mapId !== localPlayerState.mapId || !player.x || !player.y) continue; 
            
            const px = worldToCanvas(player.x, canvasWidth);
            const py = worldToCanvas(player.y, canvasHeight);
            const pr = worldToCanvas(PLAYER_RADIUS, canvasWidth);
            
            ctx.beginPath();
            ctx.arc(px, py, pr, 0, Math.PI * 2);
            ctx.fillStyle = player.color || '#9ca3af'; 
            ctx.fill();
            ctx.closePath();

            // Draw spinning effect if this player is holding the stick
            if (globalStickState.holderId === uid) {
                ctx.save();
                ctx.translate(px, py);
                // Draw a simple spinning ring
                ctx.strokeStyle = '#f97316'; // Orange for chaos
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, pr + 3, stickRotation * Math.PI / 180, (stickRotation + 180) * Math.PI / 180);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(0, 0, pr + 3, (stickRotation + 90) * Math.PI / 180, (stickRotation + 270) * Math.PI / 180);
                ctx.stroke();
                ctx.restore();
            }

            // Draw Username Text
            const username = player.username || uid.substring(0, 4);
            ctx.fillStyle = 'white';
            ctx.font = `${pr * 0.8}px Inter`;
            ctx.textAlign = 'center';
            ctx.fillText(username, px, py - pr - 2);
        }
        
        // 3. Draw Local Player (Always last, on top)
        const localX = worldToCanvas(localPlayerState.x, canvasWidth);
        const localY = worldToCanvas(localPlayerState.y, canvasHeight);
        const localR = worldToCanvas(PLAYER_RADIUS, canvasWidth);

        ctx.beginPath();
        ctx.arc(localX, localY, localR, 0, Math.PI * 2);
        ctx.fillStyle = localPlayerState.color || '#4f46e5'; 
        ctx.fill();
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.closePath();

        // Draw spinning effect if local player is holding the stick
        if (localPlayerState.hasStick) {
            ctx.save();
            ctx.translate(localX, localY);
            // Draw a simple spinning ring
            ctx.strokeStyle = '#f97316'; // Orange for chaos
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, localR + 3, stickRotation * Math.PI / 180, (stickRotation + 180) * Math.PI / 180);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(0, 0, localR + 3, (stickRotation + 90) * Math.PI / 180, (stickRotation + 270) * Math.PI / 180);
            ctx.stroke();
            ctx.restore();
        }


        // Draw Local Player Username
        const localUsername = localPlayerState.username;
        ctx.fillStyle = 'white';
        ctx.font = `${localR * 0.8}px Inter`;
        ctx.textAlign = 'center';
        ctx.fillText(localUsername, localX, localY - localR - 2);
    }

    // --- MAP TRANSITION LOGIC ---

    async function teleportPlayer(newMapId, newX, newY) {
        if (!db || !userId) return;

        // If holding the stick, drop it before teleporting
        if (localPlayerState.hasStick) {
            handleStickDrop();
        }

        localPlayerState.mapId = newMapId;
        localPlayerState.x = newX;
        localPlayerState.y = newY;
        
        localPlayerState.vx = 0;
        localPlayerState.vy = 0;
        stopMovementUpdate(); 

        const allPlayersRef = firebase.collection(db, getPlayerStatesCollectionPath(appId));
        const myStateRef = firebase.doc(allPlayersRef, userId);

        try {
            await firebase.setDoc(myStateRef, { 
                mapId: newMapId,
                x: newX, 
                y: newY, 
                lastActive: firebase.serverTimestamp() 
            }, { merge: true });
        } catch (e) {
            log(`[System] Error teleporting: ${e.message}`, 'error');
            console.error(e);
        }
    }

    function handleCanvasClick(event) {
        const canvas = document.getElementById('game-canvas');
        const rect = canvas.getBoundingClientRect();
        
        const clickX = event.clientX - rect.left;
        const clickY = event.clientY - rect.top;
        const worldClickX = canvasToWorld(clickX, canvas.width);
        const worldClickY = canvasToWorld(clickY, canvas.height);

        const currentMap = MAPS[localPlayerState.mapId];
        let wasTeleportAttempted = false;

        // 1. Check for Map Transitions (House Entry / Exit)
        for (const item of currentMap.scenery) {
            if (item.type !== 'house' && item.type !== 'exit') continue;

            const itemCenterDist = distance(localPlayerState.x, localPlayerState.y, item.x, item.y);
            const clickCenterDist = distance(worldClickX, worldClickY, item.x, item.y);
            
            if (itemCenterDist < PROXIMITY_RADIUS && clickCenterDist < PROXIMITY_RADIUS) {
                if (item.type === 'house' && item.id === 'house1_entry' && localPlayerState.mapId === 'main') {
                    teleportPlayer('house1', 50, 80); 
                    log(`[System] Entering house. Welcome inside!`, 'system');
                    wasTeleportAttempted = true;
                    return;
                } else if (item.type === 'exit' && item.targetMap && localPlayerState.mapId === 'house1') {
                    teleportPlayer(item.targetMap, item.targetX, item.targetY); 
                    log(`[System] Exiting to ${item.targetMap}.`, 'system');
                    wasTeleportAttempted = true;
                    return;
                }
            } else if (item.type === 'house' || item.type === 'exit') {
                 // Log error only if the click was far AND the player was far.
                 if (clickCenterDist > PROXIMITY_RADIUS || itemCenterDist > PROXIMITY_RADIUS) {
                    // console.error(`Entry Failed. Player or Click too far. Player Dist: ${itemCenterDist.toFixed(2)}, Click Dist: ${clickCenterDist.toFixed(2)}`);
                 }
            }
        }
        
        // 2. Elder Dot interaction
        if (!wasTeleportAttempted && currentMap.elderDot) {
            const elder = currentMap.elderDot;
            const distToElderWorld = distance(localPlayerState.x, localPlayerState.y, elder.x, elder.y);
            
            if (distToElderWorld < PROXIMITY_RADIUS) {
                const elderR = worldToCanvas(elder.r, canvas.width);
                const elderXCanvas = worldToCanvas(elder.x, canvas.width);
                const elderYCanvas = worldToCanvas(elder.y, canvas.height);
                const distToElderCanvas = distance(clickX, clickY, elderXCanvas, elderYCanvas);

                if (distToElderCanvas <= elderR) {
                    document.getElementById('elder-chat-modal').classList.remove('hidden');
                    log(`[Elder Dot] Clicked the Elder Dot!`, 'elder');
                    return;
                }
            }
        }
    }

    // --- MOVEMENT & CHAT FOCUS CONTROL ---

    function pauseMovement() {
        localPlayerState.vx = 0;
        localPlayerState.vy = 0;
        stopMovementUpdate(); 
    }

    function handleQuickChatFocus(e) {
        const chatInput = document.getElementById('chat-input');
        
        if (e.key === '/' && document.activeElement !== chatInput) {
            e.preventDefault(); 
            chatInput.focus();
            chatInput.selectionStart = chatInput.selectionEnd = chatInput.value.length;
            log('[System] Chat activated (/). Press Enter to send or Esc to close.', 'system');
        }
        
        if (e.key === 'Escape' && document.activeElement === chatInput) {
            e.preventDefault();
            chatInput.value = ''; 
            chatInput.blur(); 
            log('[System] Chat closed (Esc). Movement re-enabled.', 'system');
        }
    }
    
    function updateLocalPosition() {
        // --- STICK PICKUP CHECK ---
        if (localPlayerState.mapId === 'main' && !localPlayerState.hasStick && !globalStickState.isHeld && Date.now() > globalStickState.cooldownUntil) {
            const distToStick = distance(localPlayerState.x, localPlayerState.y, globalStickState.x, globalStickState.y);
            if (distToStick < STICK_PICKUP_DISTANCE) {
                handleStickPickup();
            }
        }
        
        if (localPlayerState.vx !== 0 || localPlayerState.vy !== 0) {
            
            const nextX = localPlayerState.x + localPlayerState.vx;
            const nextY = localPlayerState.y + localPlayerState.vy;

            let collisionDetected = false;

            // Check for collisions with other players on the same map
            for (const uid in otherPlayers) {
                const player = otherPlayers[uid];
                if (player.mapId === localPlayerState.mapId) {
                    const dist = distance(nextX, nextY, player.x, player.y);
                    
                    if (dist < PLAYER_RADIUS * 2) { 
                        collisionDetected = true;
                        
                        // If player has stick, BUMP the other player away
                        if (localPlayerState.hasStick) {
                            const dx = player.x - localPlayerState.x;
                            const dy = player.y - localPlayerState.y;
                            const totalV = Math.sqrt(dx * dx + dy * dy);
                            
                            if (totalV > 0) {
                                // Calculate normalized push vector away from local player
                                const pushX = (dx / totalV) * BUMP_MAGNITUDE;
                                const pushY = (dy / totalV) * BUMP_MAGNITUDE;
                                
                                // Send updated position for the target player
                                sendStickBump(uid, pushX, pushY);
                            }
                        }
                        // Stop local player movement regardless of stick, but only process one collision
                        break; 
                    }
                }
            }
            
            // Only move if no collision was detected
            if (!collisionDetected) {
                localPlayerState.x = nextX;
                localPlayerState.y = nextY;
            }

            // Keep player within bounds (0-100)
            localPlayerState.x = Math.max(PLAYER_RADIUS, Math.min(100 - PLAYER_RADIUS, localPlayerState.x));
            localPlayerState.y = Math.max(PLAYER_RADIUS, Math.min(100 - PLAYER_RADIUS, localPlayerState.y));
        }
    }


    function gameLoop() {
        updateLocalPosition(); 
        drawGame();
        requestAnimationFrame(gameLoop);
    }
    
    // --- FIRESTORE MOVEMENT UPDATE (THROTTLED) ---

    async function sendMovementUpdate() {
        // Only send if moving OR we just stopped and need to finalize position
        if ((localPlayerState.vx === 0 && localPlayerState.vy === 0 && movementIntervalId) || !db || !userId) {
             if (!movementIntervalId) return; 
        }

        const allPlayersRef = firebase.collection(db, getPlayerStatesCollectionPath(appId));
        const myStateRef = firebase.doc(allPlayersRef, userId);

        try {
            await firebase.setDoc(myStateRef, { 
                mapId: localPlayerState.mapId,
                x: localPlayerState.x, 
                y: localPlayerState.y, 
                lastActive: firebase.serverTimestamp() 
            }, { merge: true });
        } catch (e) {
            log(`[System] Error updating position: ${e.message}`, 'error');
            console.error(e);
        }
    }

    function startMovementUpdate() {
        if (!movementIntervalId) {
            movementIntervalId = setInterval(sendMovementUpdate, 50);
        }
    }

    function stopMovementUpdate() {
        if (movementIntervalId) {
            clearInterval(movementIntervalId);
            movementIntervalId = null;
            sendMovementUpdate(); // Send one final update
        }
    }

    // --- EVENT HANDLERS ---
    
    function handleKeyDown(e) {
        if (document.activeElement.tagName === 'INPUT') return; 

        let changed = false;
        
        switch (e.key.toLowerCase()) {
            case 'w':
            case 'arrowup':
                localPlayerState.vy = -MOVEMENT_SPEED;
                changed = true;
                break;
            case 's':
            case 'arrowdown':
                localPlayerState.vy = MOVEMENT_SPEED;
                changed = true;
                break;
            case 'a':
            case 'arrowleft':
                localPlayerState.vx = -MOVEMENT_SPEED;
                changed = true;
                break;
            case 'd':
            case 'arrowright':
                localPlayerState.vx = MOVEMENT_SPEED;
                changed = true;
                break;
        }
        
        if (changed) {
            e.preventDefault(); 
            startMovementUpdate();
        }
    }

    function handleKeyUp(e) {
        if (document.activeElement.tagName === 'INPUT') return; 

        let changed = false;
        switch (e.key.toLowerCase()) {
            case 'w':
            case 'arrowup':
            case 's':
            case 'arrowdown':
                localPlayerState.vy = 0;
                changed = true;
                break;
            case 'a':
            case 'arrowleft':
            case 'd':
            case 'arrowright':
                localPlayerState.vx = 0;
                changed = true;
                break;
        }
        
        if (changed && localPlayerState.vx === 0 && localPlayerState.vy === 0) {
            stopMovementUpdate();
        }
    }
    
    // Function to update any player property (color or username) in Firestore
    async function updatePlayerProperty(key, value) {
        if (!db || !userId) {
            log(`[System] Error: DB not ready to save ${key}.`, 'error');
            return;
        }
        const allPlayersRef = firebase.collection(db, getPlayerStatesCollectionPath(appId));
        const myStateRef = firebase.doc(allPlayersRef, userId);
        
        try {
            await firebase.setDoc(myStateRef, { [key]: value }, { merge: true });
            log(`[System] Player ${key} updated to ${value}.`, 'system');
        } catch (e) {
            log(`[System] Error updating ${key}: ${e.message}`, 'error');
            console.error(e);
        }
    }

    // Full setup of all listeners
    function setupEventListeners() {
        const chatInput = document.getElementById('chat-input');
        const colorPicker = document.getElementById('color-picker');
        const usernameInput = document.getElementById('username-input');

        // Game Controls
        document.getElementById('game-canvas').addEventListener('click', handleCanvasClick);
        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);
        window.addEventListener('resize', drawGame);

        // Chat Focus/Movement Pause Controls
        chatInput.addEventListener('focus', pauseMovement);
        chatInput.addEventListener('blur', stopMovementUpdate);
        document.addEventListener('keydown', handleQuickChatFocus); 

        // Chat Send Controls
        document.getElementById('send-btn').addEventListener('click', sendChatMessage);
        chatInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                sendChatMessage();
                e.preventDefault();
                chatInput.blur(); 
            }
        });
        
        // --- Username/Color Controls ---

        // Username Input Listener
        usernameInput.addEventListener('change', (event) => {
            const newUsername = event.target.value.trim().replace(/\s+/g, '_') || localPlayerState.username; 
            localPlayerState.username = newUsername;
            event.target.value = newUsername; 
            updatePlayerProperty('username', newUsername);
        });

        // Color Picker Listener
        colorPicker.addEventListener('change', (event) => {
            const newColor = event.target.value;
            localPlayerState.color = newColor; 
            updatePlayerProperty('color', newColor);
        });

        // Elder Dot Modal Controls
        document.getElementById('close-elder-chat').addEventListener('click', () => {
            document.getElementById('elder-chat-modal').classList.add('hidden');
        });
        document.getElementById('send-elder-query').addEventListener('click', () => {
            const query = document.getElementById('elder-query').value.trim();
            if (query) {
                document.getElementById('elder-query').value = '';
                askElderDot(query);
            }
        });
        document.getElementById('elder-query').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('send-elder-query').click();
            }
        });
    }

    // --- CHAT AND AI FUNCTIONS ---

    async function sendChatMessage() {
        const chatInput = document.getElementById('chat-input');
        const message = chatInput.value.trim();
        
        if (!message || !db || !userId) return;
        
        const chatCollectionRef = firebase.collection(db, getChatCollectionPath(appId));
        
        try {
            await firebase.setDoc(firebase.doc(chatCollectionRef), {
                userId: userId,
                message: message,
                timestamp: firebase.serverTimestamp()
            });
            chatInput.value = '';
        } catch (e) {
            log(`[System] Error sending chat: ${e.message}`, 'error');
            console.error(e);
        }
    }
    
    async function askElderDot(prompt) {
        document.getElementById('send-elder-query').disabled = true;
        document.getElementById('elder-response').textContent = "Thinking...";
        
        const systemPrompt = "You are the Elder Dot, an ancient, wise, and slightly cryptic entity residing at the center of the Dot Drift map. Provide short, insightful, and slightly mystical answers. If you must use external info, integrate it into your persona.";
        const userQuery = prompt;
        const apiKey = "" 
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

        const payload = {
            contents: [{ parts: [{ text: userQuery }] }],
            tools: [{ "google_search": {} }], 
            systemInstruction: {
                parts: [{ text: systemPrompt }]
            },
        };
        
        const maxRetries = 3;
        let attempt = 0;

        while (attempt < maxRetries) {
            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (response.ok) {
                    const result = await response.json();
                    const text = result.candidates?.[0]?.content?.parts?.[0]?.text || "The cosmos are silent. I cannot perceive an answer.";
                    
                    document.getElementById('elder-response').textContent = text;
                    log(`[Elder Dot]: ${text.substring(0, 50)}...`, 'elder');

                    const groundingMetadata = result.candidates?.[0]?.groundingMetadata;
                    if (groundingMetadata && groundingMetadata.groundingAttributions) {
                         const sources = groundingMetadata.groundingAttributions
                            .map(attr => attr.web?.title)
                            .filter(title => title);
                         if (sources.length > 0) {
                            const sourceText = " (Sources: " + sources.slice(0, 3).join(', ') + ")";
                            document.getElementById('elder-response').textContent += sourceText;
                         }
                    }
                    
                    break;
                } else {
                    throw new Error(`API failed with status ${response.status}`);
                }
            } catch (error) {
                attempt++;
                if (attempt < maxRetries) {
                    const delay = Math.pow(2, attempt) * 1000;
                    await new Promise(res => setTimeout(res, delay));
                } else {
                    document.getElementById('elder-response').textContent = `The cosmic channel is jammed. Try again later. (Error: ${error.message})`;
                    log(`[Elder Dot] API Call Failed: ${error.message}`, 'error');
                }
            }
        }
        document.getElementById('send-elder-query').disabled = false;
    }
</script>
</body>
</html>
